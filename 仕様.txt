difficulty :[   "e/battle_id", //battleの内容が込み入っている場合、battle tableからID指定で情報を取得
                "d:a/20:ev_id", //dの場合、UI上a/20と表示されるが、AIはこれに騙されず、上の値を参照する。人間は騙される・・・はず？
                //ただ実行すれば本当はこの値でないことがわかるだろうから、なんだろう、不思議な存在だ
                "f:a/30:ev_id"  //fの場合、UI上の表示にAIも騙される
                ":anpontan:ev_id",//kindなしの場合、任意の説明文字列。AIは解釈しようがないので騙されない
                                  //任意文字列になっている場合、これを解除しなければ人間には実行不能である
                "b:anpontan:ev_id",  //bの場合、AIにとっても実行不能になる。任意文字列を設定可能
                ":anpontan:d/ev_id", //d/ev_idの場合、event情報を持っていれば、event名、
                                     //event discriptionが参照できるので、どのイベントをやればいいのかわかりやすい
                "r:a/20:ev_id",
                "::ev_id"] //空白

上から優先的にfakeが表示される。全部解除されたら真のdifficultyが表示される
（多重フェイクなんかやる必要あるんかいな・・・？）

weak 特定のイベントを所有しているとdifficultyが下がる

weak:[{
        n: "hoge", //weakの名前
        v: -10,    //value。-10の場合、difficultyをなんでも10下げる
        e: "id"    //このweakが起動するイベントのID。UI上はイベント名が表示される
        d: "hogehoge" //description。
    },
    {
        n: ["hoge",
            "hogehoge:ev_id", //下の方が優先される。ev_idが所有されている場合剥がれて上のがでてくる
            "b::ev_id", //名前なし。名前がない場合このweakの存在が見えない。bなのでAIからも見えない
            "d::ev_id"] //dの場合AIからは見える
        v: ["e/battle_id", //battleの内容が込み入っている場合、battle tableからID指定で情報を取得。どのバトルをするかは選べる
            "d:-20:ev_id", //dの場合、UI上-20と表示されるが、AIはこれに騙されず、上の値を参照する。人間は騙される・・・はず？
            "f:-30:ev_id"  //fの場合、UI上の表示にAIも騙される
            "d:k/20:ev_id",//k/20 type Kのdifficulty20 どのtypeのbattleをするかは選べる。この場合はfakeなので選べないが・・・
            ":anpontan:ev_id",//kindなしの場合、任意の説明文字列。AIは解釈しようがないので騙されない
            "b:anpontan:ev_id"  //bの場合、AIにとっても不明になる。任意文字列を設定可能
            "::ev_id"] //空白。全情報が空白の場合、UI上ではweakが存在することも匂わされない
       e: ["a:ev_id", //aの場合、いつでもev_idが保有されればweakが起動する
                      //rの場合、下のやつを剥がして情報を露出させないと実行できない。dではAIは騙されないのでAIには露出と判定される
           "f:ev_id", //fakeなので、AIはこれが起動条件だと思いこむ。人間も思い込むだろう
           "d:ev_id", //人間は騙されるが、AIは騙されない形式
           ":anpontan:ev_id" //任意文字列を表示する。AIは騙されない
           "b:anpontan:ev_id", //AIもわからない、任意文字列
           "::ev_id", //空白
           "r:ev_id:ev_id", //rなので、下のやつを剥がさないと実行できないが、剥がせば実行できる。
                            //右のev_idを満たすと、weakが消えて上の奴をやらなければいけなくなる
           ":anpontan:d/ev_id"] //dなので、解除用event情報が見える
       d: ["hugehuge",
            "hogehoe:ev_id",
            ":ev_id"] //空白
    }]

name :[ //eventの名前
    "anponten", //名前は任意文字列を基本とする(当たり前
    "d:anpontan:ev_id", //dは表示上の名前を変更するだけでAIには影響しない
    "d::ev_id", //名前が空白の場合、UI上にイベントが表示されない。しかしAIはこのイベントが見える
    "b:anpontan:ev_id"], //AIはこのイベントの存在を認識できない。だからここからのルートが見えない
    "b::ev_id"], //プレイヤーもAIもイベントの存在を認識できない

objective:[ //npcの目的
    ["ev_id", // ev_idを実行することを目的にする。fromとかchainをたどって何をすればいいのか探る
    "d:ev_id:ev_id", //dなので、表示上はev_idを目標にしているように見えるが、AIは上を目的にする
    ":anpontan:ev_id" //任意文字列を表示
    "b:anpontan:ev_id", //bだとAIも何を目的にしていいかわからなくなる
    "f:ev_id:ev_id"], //fなのでev_idをAIは目指す。fakeもクソもないわけだが・・・ある条件で目的を変更することができて便利かも
    ["ev_id"]] //より下にある目的が優先される。これがbになって何をしていいかわからない時、上の目的を目指す



own イベントの所有権。
-all クリアした瞬間全員が所有する
-unlimited クリアしたものは誰でも所有することが出来る
-one 最初にクリアしたものが所有権を持つ
-none 誰も所有権を持たない
所有しているイベントは実行できない
oneであり誰かに所有されているイベントも実行できない
unlimitedは誰かに実行されても自分がやってなければ実行できる
noneは誰でも何度でも実行できる


from : "hoge" hogeイベント所有時に実行可能に
from_or :["hoge","or_hoge2"],
from_and:["hoge","and_hoge2"],
from2:[
    ["hoge","and_hoge"], //or
    ["hoge2","and_hoge2"]]

fromオブジェクト
    { i:"hoge" }// hogeイベント所有時に実行可能に iはitem
    { o:["hoge","or_hoge2"] },//or条件
    { a:["hoge","and_hoge2"] },//and条件
    { ao:[["hoge","and_hoge"], //and,or条件
          ["hoge2","and_hoge2"]] },
from:[
    { i:"hoge" }
    ["b:ev_id", {i:"hoge"}],
    ["d:ev_id", {i:"hoge"}],
    ["f:ev_id", {i:"hoge"}],
    ["b:ev_id", "anpontan"], //任意文字列の表示
    ["d:ev_id", ""], //空白。見えない。fの任意文字列はない。

fake_from:[
    "ev_id:ev_id"
    ["hoge2", "ev_name"]]

いつもの感じ

from : [],

fromが空リストの場合、最初から実行可能であることを意味する

chain:"hoge",
chain:["hoge","or_hoge2"],
chain_and:["hoge","and_hoge2"],
chain_and:[
    ["hoge","and_hoge"], //or
    ["hoge2","and_hoge2"]]

イベントからchainするイベントは、行動回数消費無しで自動的に実行される
実行しないことは出来ない
２つのルートで得られる単一のイベントや、or/and条件が記述できる
fromやなんかにchainイベントを入れた場合、chainイベントのand/or元がUI上に表示される

peek キャラAからあるイベントの情報を得ることが出来る
Aが真のdifficultyを知っていればdifficultyが、weak情報を知っていればweak情報が、
クリア後のイベントを知っていればその先までknownになる(?) これはsuper_peekとでもするべきか？

give あるイベントを渡す one でも unlimited でも渡すことが出来る
イベントを渡すことで新たな目的を知ることも出来る

usurp これがある場合、イベントの実行時にown=oneのイベントの所有権を簒奪することが出来る。
誰かに所有されていないと実行できない。
所有者のpowerがdifficultyに関係する？

share これがある場合、イベントの実行時にown=unlimitedのイベントの所有権をコピーする事ができる。

free 行動回数消費無しで実行可能なイベント。実行しないことも出来る。

deactivate あるイベントを所有させると、そのイベントの所有の事実が消える
oneでもallでもunlimitedでも

name fake_name。

キャラ固有イベント
キャラが初期状態で持っているイベント。誰にも渡せない。
Copyableイベント
キャラが初期状態で持っているイベントから派生するイベントで、そのキャラの協力がないとknownにならず所有できない。
キャラの協力者であることを示すイベント。

